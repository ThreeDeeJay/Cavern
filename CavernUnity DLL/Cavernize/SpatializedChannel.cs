using System;
using UnityEngine;

using Cavern.Filters;

namespace Cavern.Cavernize {
    /// <summary>All the data <see cref="Cavernizer"/> needs for a single channel.</summary>
    class SpatializedChannel {
        /// <summary>Channel position and type information.</summary>
        public readonly CavernizeChannel Channel;
        /// <summary>Crossover to split the moving and ground part.</summary>
        public readonly Crossover Filter;
        /// <summary>Samples to split between <see cref="MovingSource"/> and <see cref="GroundSource"/>.</summary>
        public readonly float[] Output;
        /// <summary>There is available output data, and the channel should be rendered.</summary>
        public bool WrittenOutput;
        /// <summary>High frequency data with height information.</summary>
        public CavernizeOutput MovingSource { get; private set; }
        /// <summary>Low frequency data that stays on the ground.</summary>
        public CavernizeOutput GroundSource { get; private set; }
        /// <summary>Last low frequency sample (used in the height calculation algorithm).</summary>
        public float LastLow;
        /// <summary>Last unmodified sample (used in the height calculation algorithm).</summary>
        public float LastNormal;
        /// <summary>Last high frequency sample (used in the height calculation algorithm).</summary>
        public float LastHigh;
        /// <summary>The moving part's normalized height from the ground.</summary>
        public float Height;
        /// <summary>Times the sources called for a set of samples. Numbers >= 2 indicate that the next frame should be mixed.</summary>
        public int TicksTook;
        /// <summary>Renderer for <see cref="MovingSource"/>.</summary>
        public Renderer MovingRenderer { get; private set; }
        /// <summary>Renderer for <see cref="GroundSource"/>.</summary>
        public Renderer GroundRenderer { get; private set; }

        void CreateSource(Cavernizer Master, bool GroundLevel) {
            GameObject NewObject;
            if (Channel != CavernizeChannel.ScreenLFE)
                NewObject = GameObject.CreatePrimitive(PrimitiveType.Sphere);
            else
                NewObject = GameObject.CreatePrimitive(PrimitiveType.Cube);
            NewObject.name = Channel.Name;
            CavernizeOutput NewSource = NewObject.AddComponent<CavernizeOutput>();
            NewSource.Master = Master;
            NewSource.Channel = this;
            if (NewSource.GroundLevel = GroundLevel) {
                GroundSource = NewSource;
                GroundRenderer = NewObject.GetComponent<Renderer>();
            } else {
                MovingSource = NewSource;
                MovingRenderer = NewObject.GetComponent<Renderer>();
            }
            NewSource.CavernClip = new Clip(new float[1][] { new float[1] }, AudioListener3D.Current.SampleRate);
            NewSource.Loop = true;
            NewSource.VolumeRolloff = Rolloffs.Disabled;
            NewSource.LFE = Channel.LFE;
            // TODO: make this work with custom sample collectors
            //NewObject.AddComponent<ScaleByGain>().Source = NewSource;
            if (Channel.Muted)
                NewSource.Volume = 0;
            NewObject.transform.SetParent(Master.transform);
            NewObject.transform.localPosition =
                Vector3.Scale(CavernUtilities.PlaceInCube(new Vector3(0, Channel.Y)), AudioListener3D.EnvironmentSize);
        }

        public SpatializedChannel(CavernizeChannel Source, Cavernizer Master, int UpdateRate) {
            Channel = Source;
            Filter = new Crossover(AudioListener3D.Current.SampleRate, 250);
            Output = new float[UpdateRate];
            CreateSource(Master, true);
            CreateSource(Master, false);
        }

        public void Tick(float EffectMult, float SmoothFactor, float CrossoverFreq, bool Visualize) {
            int Samples = Output.Length;
            if (!WrittenOutput)
                Array.Clear(Output, 0, Samples);
            if (Filter.Frequency != CrossoverFreq)
                Filter.Frequency = CrossoverFreq;
            Filter.Process(Output);
            MovingRenderer.enabled = GroundRenderer.enabled = Visualize && WrittenOutput;
            if (WrittenOutput) {
                float MaxDepth = .0001f, MaxHeight = .0001f;
                for (int Offset = 0; Offset < Samples; ++Offset) {
                    // Height is generated by a simplified measurement of volume and pitch
                    LastHigh = .9f * (LastHigh + Output[Offset] - LastNormal);
                    float AbsHigh = Math.Abs(LastHigh);
                    if (MaxHeight < AbsHigh)
                        MaxHeight = AbsHigh;
                    LastLow = LastLow * .99f + LastHigh * .01f;
                    float AbsLow = Math.Abs(LastLow);
                    if (MaxDepth < AbsLow)
                        MaxDepth = AbsLow;
                    LastNormal = Output[Offset];
                }
                MaxHeight = (MaxHeight - MaxDepth * 1.2f) * EffectMult;
                if (MaxHeight < -.2f)
                    MaxHeight = -.2f;
                else if (MaxHeight > 1)
                    MaxHeight = 1;
                Height = CavernUtilities.FastLerp(Height, MaxHeight, SmoothFactor);
                Transform TargetTransform = MovingSource.transform;
                Vector3 OldPos = TargetTransform.localPosition;
                TargetTransform.localPosition = CavernUtilities.FastLerp(OldPos,
                    new Vector3(OldPos.x, MaxHeight * AudioListener3D.EnvironmentSize.y, OldPos.z), SmoothFactor);
            }
        }

        public void Destroy() {
            if (MovingSource)
                UnityEngine.Object.Destroy(MovingSource.gameObject);
            if (GroundSource)
                UnityEngine.Object.Destroy(GroundSource.gameObject);
        }
    }
}